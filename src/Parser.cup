import java_cup.runtime.*;

parser code {:
  public boolean syntaxErrors;

  public void syntax_error(Symbol current_token) {
    syntaxErrors = true;
    report_error( "Syntax error at line " + (current_token.left+1) + ", column " + current_token.right + "\n", null);
  }

:};

//global operators
terminal ASSIGN, SEMI, COMMA, COLON;

//parentases
terminal L_SOFT_PAREN, L_TRI_PAREN, L_SQ_PAREN, L_CURL_PAREN;
terminal R_SOFT_PAREN, R_TRI_PAREN, R_SQ_PAREN, R_CURL_PAREN;

//types
terminal INTEGER, RATIONAL, FLOAT, DICTIONARY, SEQUENCE, SET, BOOLEAN, TOP;

//keywords
terminal ALIAS, THREAD, FUN_DEF, FUNCTION, TYPE_DEF, RETURN;

//conditionals
terminal IF, THEN, ELIF, ELSE, FI;

//loops
terminal WHILE, FORALL, DO, OD, BREAK;

//built-in functions
terminal MAIN, PRINT, READ;

//booleans
terminal TRUE, FALSE;

//math
terminal PLUS, MINUS, MULTI, DIVISION, POWER;

//logic
terminal AND, NOT, OR;

//comparison
terminal SMALLER_EQ, BIGGER_EQ, EQUAL, NOT_EQ; //TODO: REMEMBER ABOUT < AND >!!!

//set operations
terminal SET_UNION, SET_INTSECT, SET_DIFF, IN;

//seq operations
terminal SEQ_CONCAT, LEN;

terminal IDENTIFIER, INTEGER_LITERAL, RATIONAL_LITERAL, FLOAT_LITERAL, STRING_LITERAL, CHAR_LITERAL;

//TOP LEVEL
non terminal expr, expr_stmt, statement, compound_stmnt;


//HELPERS
non terminal id, uncheckable_id;

//LIST
non terminal id_list, type_list, stmnt_list;

non terminal user_defined_variable, logic_expr, function_call, var_assignment;

non terminal elif, return, break;

non terminal tdef, var_list, single_var, array_call, comp_operator, type;

non terminal seq_assignment, seq_literal, seq_call, dict_assignment, dict_literal, dict_element_list, thread_literal;

precedence left PLUS, MINUS;
precedence left L_SOFT_PAREN, R_SOFT_PAREN, L_TRI_PAREN, R_TRI_PAREN, L_SQ_PAREN,R_SQ_PAREN, L_CURL_PAREN, R_CURL_PAREN;
precedence right POWER;

user_defined_variable ::= IDENTIFIER;

expr_stmt ::= expr SEMI
 | error SEMI
 ;

expr ::= expr PLUS expr
 | expr MULTI expr
 | expr MINUS expr
 | expr POWER expr
 | expr DIVISION expr
 | L_SOFT_PAREN expr R_SOFT_PAREN
 | user_defined_variable
 | id
 ;

 uncheckable_id ::= user_defined_variable
   | function_call
   | array_call
   ;

 id ::= CHAR_LITERAL
  | STRING_LITERAL
  | FLOAT_LITERAL
  | INTEGER_LITERAL
  | RATIONAL_LITERAL
//  | set_literal
  | seq_literal
  | user_defined_variable
  | function_call
  | array_call
  ;

 comp_operator ::= SMALLER_EQ
 | BIGGER_EQ
 | EQUAL
 | NOT_EQ
 | L_TRI_PAREN
 | R_TRI_PAREN
 ;

 logic_expr ::= id
  | id comp_operator id
  ;

 id_list ::= id
  | id COMMA id
  ;

 type ::= INTEGER
 | RATIONAL
 | FLOAT
 | DICTIONARY
 | SEQUENCE
 | SET
 | BOOLEAN
 | TOP
 ;

 type_list ::= type
  | type COMMA type
  ;

  statement ::= function_call
   | compound_stmnt
   | var_assignment
   | seq_assignment
   | dict_assignment
   | return
   | break
   ;

  stmnt_list ::= statement
   | statement statement
   ;

 function_call ::= user_defined_variable  L_SOFT_PAREN id_list R_SOFT_PAREN;

//Loops and Ifs

 compound_stmnt ::= FORALL L_SOFT_PAREN user_defined_variable IN id R_SOFT_PAREN DO stmnt_list OD
  | WHILE expr DO stmnt_list OD
  | IF L_SOFT_PAREN logic_expr R_SOFT_PAREN THEN stmnt_list FI
  | IF L_SOFT_PAREN logic_expr R_SOFT_PAREN THEN stmnt_list elif
  | IF L_SOFT_PAREN logic_expr R_SOFT_PAREN THEN stmnt_list ELSE stmnt_list FI
  | IF L_SOFT_PAREN logic_expr R_SOFT_PAREN THEN stmnt_list elif ELSE stmnt_list FI
  ;

 elif ::= ELIF L_SOFT_PAREN logic_expr R_SOFT_PAREN THEN stmnt_list FI
  | ELIF L_SOFT_PAREN logic_expr R_SOFT_PAREN THEN stmnt_list elif
  ;

 return ::= RETURN id;
 break ::= BREAK id
  | BREAK
  ;



//math expressions:

//operator ::=
/*
 math_expr ::= id
 | L_SOFT_PAREN expr R_SOFT_PAREN
 | expr operator expr
 ;
*/


//variables

 var_assignment ::= type user_defined_variable ASSIGN id
  | user_defined_variable ASSIGN expr
  ;

// tdef

tdef ::= TYPE_DEF IDENTIFIER L_CURL_PAREN var_list R_CURL_PAREN;

var_list ::= single_var
 | single_var COMMA single_var
 ;

single_var ::= type user_defined_variable;


//TODO should user_defined_variable and user_defined_type be treated differently?

//TODO var_reassignment

//sequences

 seq_assignment ::= SEQUENCE L_TRI_PAREN type R_TRI_PAREN user_defined_variable ASSIGN seq_literal
  | L_TRI_PAREN type R_TRI_PAREN user_defined_variable ASSIGN expr
  ;

 seq_literal ::= L_SQ_PAREN id_list R_SQ_PAREN;

 seq_call ::= L_SQ_PAREN id R_SQ_PAREN;

//dictionaries

 dict_assignment ::= DICTIONARY L_TRI_PAREN type_list R_TRI_PAREN user_defined_variable ASSIGN dict_literal
  | DICTIONARY L_TRI_PAREN type_list R_TRI_PAREN user_defined_variable ASSIGN expr
  ;

 dict_literal ::= L_SOFT_PAREN dict_element_list R_SOFT_PAREN;

 dict_element_list ::= id COLON id
  | id COLON id COMMA id COLON id
  ;

//threads
 thread_literal ::= L_CURL_PAREN stmnt_list R_CURL_PAREN;

 array_call ::= L_SQ_PAREN expr R_SQ_PAREN;
