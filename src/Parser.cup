import java_cup.runtime.*;

parser code {:
  public boolean syntaxErrors;

  public void syntax_error(Symbol current_token) {
    //syntaxErrors = true;
    report_error( "Syntax error at line " + (current_token.left+1) + ", column " + current_token.right + "\n", null);
  }

:};

//global operators
terminal ASSIGN, SEMI, COMMA, COLON;

//parentases
terminal L_SOFT_PAREN, L_TRI_PAREN, L_SQ_PAREN, L_CURL_PAREN;
terminal R_SOFT_PAREN, R_TRI_PAREN, R_SQ_PAREN, R_CURL_PAREN;

//types
terminal INTEGER, RATIONAL, FLOAT, DICTIONARY, SEQUENCE, SET, BOOLEAN, TOP, VOID, STRING_TYPE;

//keywords
terminal ALIAS, THREAD, FUN_DEF, FUNCTION, TYPE_DEF, RETURN;

//conditionals
terminal IF, THEN, ELIF, ELSE, FI;

//loops
terminal WHILE, FORALL, DO, OD, BREAK;

//built-in functions
terminal MAIN, PRINT, READ;

//booleans
terminal TRUE, FALSE;

//math
terminal PLUS, MINUS, MULTI, DIVISION, POWER;

//logic
terminal AND, NOT, OR;

//comparison
terminal SMALLER_EQ, BIGGER_EQ, EQUAL, NOT_EQ; //TODO: REMEMBER ABOUT < AND >!!!

//set operations
terminal SET_UNION, SET_INTSECT, SET_DIFF, IN;

//seq operations
terminal SEQ_CONCAT, LEN;

terminal IDENTIFIER, INTEGER_LITERAL, RATIONAL_LITERAL, FLOAT_LITERAL, STRING_LITERAL, CHAR_LITERAL;

//TOP LEVEL
non terminal expr, statement, compound_stmnt;

non terminal main;

//HELPERS
non terminal id;

//LIST
non terminal id_list, type_list, stmnt_list;

non terminal logic_expr, function_call, var_assignment;

non terminal elif, return, break;

non terminal tdef, var_list, single_var, array_call, comp_operator, type;

non terminal seq_assignment, seq_literal, seq_call, dict_assignment, dict_literal, dict_element_list, thread_assignment;

non terminal fdef;


precedence left PLUS, MINUS, DIVISION, MULTI;
precedence left L_SOFT_PAREN, R_SOFT_PAREN;
precedence left L_TRI_PAREN, R_TRI_PAREN;
precedence left L_SQ_PAREN, R_SQ_PAREN;
precedence left L_CURL_PAREN, R_CURL_PAREN;
precedence right POWER;
precedence left ELSE;
precedence left ELIF;

start with main;

main ::= MAIN L_CURL_PAREN stmnt_list R_CURL_PAREN SEMI;

statement ::= function_call SEMI
    | compound_stmnt
    | var_assignment SEMI
    | seq_assignment SEMI
    | dict_assignment SEMI
    | return SEMI
    | break SEMI
    | PRINT expr SEMI
    ;

expr ::= id //id contains IDENTIFIER
    | expr PLUS expr
    | expr MULTI expr
    | expr MINUS expr
    | expr POWER expr
    | expr DIVISION expr
    | L_SOFT_PAREN expr R_SOFT_PAREN
    | READ SEMI
    ;

compound_stmnt ::= FORALL L_SOFT_PAREN IDENTIFIER IN id R_SOFT_PAREN DO stmnt_list OD
    | WHILE logic_expr DO stmnt_list OD
    | IF L_SOFT_PAREN logic_expr R_SOFT_PAREN THEN stmnt_list FI
    | IF L_SOFT_PAREN logic_expr R_SOFT_PAREN THEN stmnt_list elif
    | IF L_SOFT_PAREN logic_expr R_SOFT_PAREN THEN stmnt_list ELSE stmnt_list FI
    | IF L_SOFT_PAREN logic_expr R_SOFT_PAREN THEN stmnt_list elif ELSE stmnt_list FI
    ;

 id ::= CHAR_LITERAL
  | STRING_LITERAL
  | FLOAT_LITERAL
  | INTEGER_LITERAL
  | RATIONAL_LITERAL
//  | set_literal
  | seq_literal
  | IDENTIFIER
  | function_call
  | array_call
  ;

 comp_operator ::= SMALLER_EQ
 | BIGGER_EQ
 | EQUAL
 | NOT_EQ
 | L_TRI_PAREN
 | R_TRI_PAREN
 ;

 logic_expr ::= id
  | id comp_operator id
  ;

 id_list ::= COMMA id
  | COMMA id_list
  ;

 type ::= INTEGER
 | RATIONAL
 | FLOAT
 | DICTIONARY
 | SEQUENCE
 | SET
 | BOOLEAN
 | TOP
 | IDENTIFIER
 | VOID
 | STRING_TYPE
 ;

 type_list ::= type
  | type_list COMMA type
  ;

  stmnt_list ::= statement
   | stmnt_list statement
   ;

 function_call ::= IDENTIFIER L_SOFT_PAREN id_list R_SOFT_PAREN
  | IDENTIFIER L_SOFT_PAREN id id_list R_SOFT_PAREN;

 elif ::= ELIF L_SOFT_PAREN logic_expr R_SOFT_PAREN THEN stmnt_list FI
  | ELIF L_SOFT_PAREN logic_expr R_SOFT_PAREN THEN stmnt_list elif
  ;

 return ::= RETURN expr
  | RETURN
  ;

 break ::= BREAK expr
  | BREAK
  ;

//I can't enforce no return in void
fdef ::= FUN_DEF type IDENTIFIER L_SOFT_PAREN var_list R_SOFT_PAREN L_CURL_PAREN stmnt_list R_CURL_PAREN SEMI;


//variables

 var_assignment ::= type IDENTIFIER ASSIGN id
  | IDENTIFIER ASSIGN expr
  ;

  //TODO var_reassignment


tdef ::= TYPE_DEF IDENTIFIER L_CURL_PAREN var_list R_CURL_PAREN;

var_list ::= type IDENTIFIER
 | var_list COMMA type IDENTIFIER
 ;

//TODO should user_defined_variable and user_defined_type be treated differently?

//sequences

 seq_assignment ::= SEQUENCE L_TRI_PAREN type R_TRI_PAREN IDENTIFIER ASSIGN seq_literal
  | L_TRI_PAREN type R_TRI_PAREN IDENTIFIER ASSIGN expr
  ;

 seq_literal ::= L_SQ_PAREN id_list R_SQ_PAREN
  | L_SQ_PAREN id id_list R_SQ_PAREN
  ;

 seq_call ::= L_SQ_PAREN id R_SQ_PAREN;

//dictionaries

 dict_assignment ::= DICTIONARY L_TRI_PAREN type_list R_TRI_PAREN IDENTIFIER ASSIGN dict_literal
  | DICTIONARY L_TRI_PAREN type_list R_TRI_PAREN IDENTIFIER ASSIGN expr
  ;

 dict_literal ::= L_SOFT_PAREN dict_element_list R_SOFT_PAREN;

 dict_element_list ::= id COLON id
  | dict_element_list COMMA id COLON id
  ;

//threads
 thread_assignment ::= THREAD id ASSIGN L_CURL_PAREN stmnt_list R_CURL_PAREN;

 array_call ::= L_SQ_PAREN expr R_SQ_PAREN;
