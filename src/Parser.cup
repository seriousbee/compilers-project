import java_cup.runtime.*;

parser code {:
  public boolean syntaxErrors;

  public void syntax_error(Symbol current_token) {
    //syntaxErrors = true;
    report_error( "Syntax error at line " + (current_token.left+1) + ", column " + current_token.right + "\n", null);
  }

:};

//global operators
terminal ASSIGN, SEMI, COMMA, COLON, DOT, PIPE, ARROW;

//parentases
terminal L_SOFT_PAREN, L_TRI_PAREN, L_SQ_PAREN, L_CURL_PAREN;
terminal R_SOFT_PAREN, R_TRI_PAREN, R_SQ_PAREN, R_CURL_PAREN;

//types
terminal INTEGER, RATIONAL, FLOAT, DICTIONARY, SEQUENCE, SET, BOOLEAN, TOP, VOID, STRING_TYPE;

//keywords
terminal ALIAS, THREAD, FUN_DEF, FUNCTION, TYPE_DEF, RETURN;

//conditionals
terminal IF, THEN, ELIF, ELSE, FI;

//loops
terminal WHILE, FORALL, DO, OD, BREAK;

//built-in functions
terminal MAIN, PRINT, READ;

//booleans
terminal TRUE, FALSE;

//math
terminal PLUS, MINUS, MULTI, DIVISION, POWER;

//logic
terminal AND, NOT, OR;

//comparison
terminal SMALLER_EQ, BIGGER_EQ, EQUAL, NOT_EQ;

//set operations
terminal SET_UNION, SET_INTSECT, SET_DIFF, IN;

//seq operations
terminal SEQ_CONCAT;

terminal IDENTIFIER, INTEGER_LITERAL, RATIONAL_LITERAL, FLOAT_LITERAL, STRING_LITERAL, CHAR_LITERAL;

//TOP LEVEL
non terminal expr, statement, compound_stmnt;

non terminal main;

//LIST
non terminal expr_list, type_list, stmnt_list;

non terminal function_call, var_assignment;

non terminal elif, return, break;

non terminal tdef, var_list, binary_operator, type;

non terminal seq_assignment, seq_literal, seq_call, dict_assignment, dict_literal, dict_element_list, thread_assignment;

non terminal var_declaration, seq_declaration, dict_declaration, property_call;

non terminal fdef, starter, alias, lambda, lambda_list;


precedence left PLUS, MINUS, DIVISION, MULTI;
precedence left L_SOFT_PAREN, R_SOFT_PAREN;
precedence left L_TRI_PAREN, R_TRI_PAREN;
precedence left L_SQ_PAREN, R_SQ_PAREN;
precedence left L_CURL_PAREN, R_CURL_PAREN;
precedence right POWER;
precedence left ELSE;
precedence left ELIF;
precedence left BIGGER_EQ, EQUAL, SMALLER_EQ, NOT_EQ, AND, OR, DOT;
precedence left SEQ_CONCAT, SET_INTSECT, PIPE, SET_DIFF, SET_UNION;

start with starter;

//TODO: Problems:
    //comments: /# do something else #/
    //function calls: return fibonacci(pos-1) + fibonacci(pos-2);
    //seq literal: seq<int> a := [1, 2, 3];
    //dict assignment: 	dict<int,int> x := ( );
    //identifier? fdef foo( int pos ) {
    //alias keyword + assignment: alias seq<char> string;
    //strings: string s1 := "Alice in Wonderland";, seq<string> l1 := ["a","b", "c", "d", "e"];
    //int literal? 	seq<int> a := [1, 2, 3];
    //lambdas:     function mul := |a| -> |b| -> { return a * b; };
    //set keyword? + literals:     set<int> a := {0, 1, 2};
    //support of ab[4].element

starter ::= tdef SEMI starter
 | fdef SEMI starter
 | var_assignment SEMI starter
 | dict_assignment SEMI starter
 | seq_assignment SEMI starter
 | var_declaration SEMI starter
 | seq_declaration SEMI starter
 | dict_declaration SEMI starter
 | thread_assignment SEMI starter
 | alias SEMI starter
 | lambda SEMI starter
 | main
 ;

statement ::= function_call SEMI
    | compound_stmnt
    | var_assignment SEMI
    | var_declaration SEMI
    | seq_assignment SEMI
    | seq_declaration SEMI
    | dict_assignment SEMI
    | dict_declaration SEMI
    | thread_assignment SEMI
    | return SEMI
    | break SEMI
    | PRINT expr SEMI
    | tdef SEMI
    | fdef SEMI
    | alias SEMI
    | lambda SEMI
    ;

expr ::= IDENTIFIER
    | expr binary_operator expr
    | MINUS expr
    | NOT expr
    | READ SEMI
    | CHAR_LITERAL
    | STRING_LITERAL
    | FLOAT_LITERAL
    | INTEGER_LITERAL
    | RATIONAL_LITERAL
    | seq_literal
    | function_call
    | seq_call
    | dict_literal
    | property_call
    | TRUE
    | FALSE
    ;

main ::= MAIN L_CURL_PAREN stmnt_list R_CURL_PAREN SEMI
 | MAIN L_CURL_PAREN R_CURL_PAREN SEMI;

compound_stmnt ::= FORALL L_SOFT_PAREN IDENTIFIER IN expr R_SOFT_PAREN DO stmnt_list OD
    | WHILE expr DO stmnt_list OD
    | IF L_SOFT_PAREN expr R_SOFT_PAREN THEN stmnt_list FI
    | IF L_SOFT_PAREN expr R_SOFT_PAREN THEN stmnt_list elif
    | IF L_SOFT_PAREN expr R_SOFT_PAREN THEN stmnt_list ELSE stmnt_list FI
    | IF L_SOFT_PAREN expr R_SOFT_PAREN THEN stmnt_list elif ELSE stmnt_list FI
    ;

property_call ::= expr DOT IDENTIFIER;

 binary_operator ::= SMALLER_EQ
 | BIGGER_EQ
 | EQUAL
 | NOT_EQ
 | L_TRI_PAREN
 | R_TRI_PAREN
 | MINUS
 | MULTI
 | PLUS
 | POWER
 | DIVISION
 | OR
 | AND
 | SEQ_CONCAT
 | SET_INTSECT
 | PIPE
 | SET_DIFF
 | SET_UNION
 ;

 type ::= INTEGER
 | RATIONAL
 | FLOAT
 | DICTIONARY
 | SEQUENCE
 | SET
 | BOOLEAN
 | TOP
 | IDENTIFIER
 | VOID
 | STRING_TYPE
 ;

 function_call ::= IDENTIFIER seq_literal;

 elif ::= ELIF L_SOFT_PAREN expr R_SOFT_PAREN THEN stmnt_list FI
  | ELIF L_SOFT_PAREN expr R_SOFT_PAREN THEN stmnt_list elif
  ;

 return ::= RETURN expr
  | RETURN
  ;

 break ::= BREAK expr
  | BREAK
  ;

//variables

 var_assignment ::= type IDENTIFIER ASSIGN expr
  | IDENTIFIER ASSIGN expr
  ;

var_declaration ::= type IDENTIFIER;

fdef ::= FUN_DEF type IDENTIFIER L_SOFT_PAREN var_list R_SOFT_PAREN L_CURL_PAREN stmnt_list R_CURL_PAREN SEMI
    | FUN_DEF type IDENTIFIER L_SOFT_PAREN var_list R_SOFT_PAREN L_CURL_PAREN R_CURL_PAREN SEMI;
tdef ::= TYPE_DEF IDENTIFIER L_CURL_PAREN var_list R_CURL_PAREN;
thread_assignment ::= THREAD IDENTIFIER ASSIGN L_CURL_PAREN stmnt_list R_CURL_PAREN
    | THREAD IDENTIFIER ASSIGN L_CURL_PAREN  R_CURL_PAREN;

//sequences

seq_assignment ::= SEQUENCE L_TRI_PAREN type R_TRI_PAREN IDENTIFIER ASSIGN expr;
seq_declaration ::= SEQUENCE L_TRI_PAREN type R_TRI_PAREN IDENTIFIER;
seq_literal ::= L_SOFT_PAREN R_SOFT_PAREN
    | L_SOFT_PAREN expr R_SOFT_PAREN
    | L_SOFT_PAREN expr expr_list R_SOFT_PAREN
    ;

seq_call ::= L_SQ_PAREN expr R_SQ_PAREN;


//dictionaries
dict_assignment ::= DICTIONARY L_TRI_PAREN type_list R_TRI_PAREN IDENTIFIER ASSIGN expr;
dict_declaration ::= DICTIONARY L_TRI_PAREN type_list R_TRI_PAREN IDENTIFIER;

dict_literal ::= L_SOFT_PAREN expr COLON expr dict_element_list R_SOFT_PAREN
    ;

alias ::= ALIAS expr IDENTIFIER;

lambda ::= FUNCTION IDENTIFIER ASSIGN PIPE IDENTIFIER PIPE ARROW L_CURL_PAREN stmnt_list R_CURL_PAREN
 | FUNCTION IDENTIFIER ASSIGN PIPE IDENTIFIER PIPE ARROW L_CURL_PAREN R_CURL_PAREN
 | FUNCTION IDENTIFIER ASSIGN PIPE IDENTIFIER PIPE lambda_list ARROW L_CURL_PAREN stmnt_list R_CURL_PAREN
 | FUNCTION IDENTIFIER ASSIGN PIPE IDENTIFIER PIPE lambda_list ARROW L_CURL_PAREN R_CURL_PAREN
 ;

//LISTS
type_list ::= type
    | type_list COMMA type
    ;

stmnt_list ::= statement
    | stmnt_list statement
    ;

dict_element_list ::= expr COLON expr
    | dict_element_list COMMA expr COLON expr
    ;

var_list ::= type IDENTIFIER
    | var_list COMMA type IDENTIFIER
    ;

expr_list ::= COMMA expr
    | COMMA expr_list
    ;
lambda_list ::= ARROW PIPE IDENTIFIER PIPE
    | ARROW PIPE IDENTIFIER PIPE lambda_list
    ;